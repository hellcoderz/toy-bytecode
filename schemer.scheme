; reader utility functions
(define isspace (lambda (c) (or (char=? c #\space ) (or (char=? c #\tab) (char=? c #\newline)))))
(define next-non-ws (lambda () (lambda (z) (if (isspace z) (next-non-ws) z)) (read-char)))

; other utility functions
(define for-all? (lambda (f l) (if (null? l) 
				   #t
				   (if (f (car l))
				       (for-all? f (cdr l)) #f))))

(define is-number? (lambda (str)
		     (for-all? (lambda (x) (and (char>=? x #\0)  (char<=? x #\9)))
			       (string->list str))))

(define asm-number  (lambda (x) (string-append "n" (if (number? x) (number->string x) x))))
(define asm-pointer (lambda (x y) (string-append "p" (if (number? x) (number->string x) x) 
						 "," (if (number? x) (number->string y) y)
						 )))
(define asm-lang-const (lambda (x) (string-append "l" (if (number? x) (number->string x) x))))

; identifies functions that have special meaning
; to the compiler.
(define builtin-forms 
  (lambda ()
    (list
     (cons "lambda" compile-lambda)
     (cons "if"     compile-if)
     (cons "define" compile-define)  
     (cons "begin"  compile-begin)
     )
    ))

(define find-builtin 
  (lambda (f ss)
    (if (null? ss) #f
	(if (and (string? f) 
		 (string= f (car (car ss))))
	    (cdr (car ss))
	    (find-builtin f (cdr ss))))))


; I really need to fix the object representation 
; scheme.  Right now pointers are identified by setting
; the high bit (and all pointers point to cons boxes)
; and false = 0 and true = 1.  This isn't really ideal
; because it breaks scheme's model where false (#f) and true (#t)
; are not integers, and it makes negative numbers kinda tricky.  
; 
; I may end up pushing this down to the VM level and defining 
; something like:
; bit 0 set        -> pointer, 
;                     object size is in bits 2-10 location in bits 11 to 31 
; bit 1 set        -> language defined constant.  
; bits 0 & 1 clear -> immediate integer value in bits 2-31
;
; The VM would do type checking on operations 
; (LOAD, STORE, and ARITHMETIC), 
; PUSH would take an immediate numeric argument (and shift left by two)
; new instructions TOP, and TOC, and TOI would coerce between the types
(define true-value (asm-lang-const 1))
(define false-value (asm-lang-const 0))

; these are runtime constants used for tracking
; the heap and the environment

(define top-level-env '(("=" "cons" "car" "cdr" "+" "-" "*")))

; this is the compiler internal notion of what instruction
; is currently being written
(define instruction-pointer 0)
(define increment-ip (lambda ()
  (set! instruction-pointer (+ 1 instruction-pointer))))

(define label-counter 0)
(define fresh-label (lambda ()
		      (set! label-counter (+ label-counter 1))
		      (string-append "__anonymous" (number->string label-counter))
		      ))

; append an instruction to the ouptut stream
(define append-instruction
  (lambda (ins)
    (begin 
      (display ins)
      (display "\n")
      (increment-ip)
    )
))
  
; append a list of instructions to the output stream
(define append-instructions 
  (lambda (inss)
    (if (null? inss) '()
	(begin
	  (append-instruction (car inss))
	  (append-instructions (cdr inss))))))

(define assembly-increment (lambda ()
		       (append-instructions 
			(list "PUSH" (asm-number 1) "ADD"))))

; append assembly code for storing a value to the next free
; heap cell.
; (val)  -> (hp*) , hp' = hp+1, heap[hp] = val
(define store-to-heap (lambda ()
			(append-instructions
			 (list "PUSH" (asm-number 1)   ; (thing 1)
			       "ALOC"                  ; (thing hp)
			       "DUP"                   ; (thing hp hp)
			       "ROT"                   ; (hp thing hp)
			       "PUSH" (asm-number 0)   ; (hp thing hp 0)
			       "STOR"))))

			   
; assembly for the primitive list functions car, cdr, and cons
; (ptr*) -> ((car ptr))
(define assembly-car  (lambda () (append-instructions (list "PUSH" (asm-number 0) "LOAD"))))

; (ptr*) -> ((cdr ptr))
(define assembly-cdr  (lambda () (append-instructions (list "PUSH" (asm-number 1) "LOAD"))))


; (cdr car) -> ((cons car cdr))
(define assembly-cons (lambda ()
			(append-instructions 
			 (list "PUSH" (asm-number 2) ; (cdr car 2)
			       "ALOC"                ; (cdr car &hp)
			       "DUP"                 ; (cdr car hp hp)
			       "ROT"                 ; (cdr hp car hp)
			       "PUSH" (asm-number 0) ; (cdr hp car hp 0)
			       "STOR"                ; (cdr hp) car stored
			       "DUP"))               ; (cdr hp hp)
			(append-instructions
			 (list "ROT"                 ; (hp cdr hp)
			       "PUSH" (asm-number 1) ; (hp cdr hp 1)
			       "STOR"))              ; (hp)  cdr stored
			))


; top is the cons box to set, then the new value
(define assembly-set-car 
  (lambda () (append-instructions (list "PUSH" (asm-number 0) "STOR"))))
(define assembly-set-cdr 
  (lambda () (append-instructions (list "PUSH" (asm-number 1) "STOR"))))


; these define how to call the three primitives car, cdr, and cons as
; part of larger compiler generated sequences (e.g., function application)
; for car, we just inline the assembly.  For cdr and cons we do a machine level
; call into a function.
(define u-call-car  (lambda () (assembly-car))) ; car is 4 instructions, calling it is three
					        ; the performance benefit of inlining calls outweighs
					        ; the space savings.

(define u-call-cdr  ; cdr is 7 instructions,  it's probably worth not inlining it
  (lambda () (append-instructions (list "PUSH" "@__u_cdr" "CALL"))))

(define u-call-cons ; cons is really big (24 instructions)! we'll never inline it
  (lambda () (append-instructions (list "PUSH" "@__u_cons" "CALL"))))

(define u-call-set-car (lambda () (assembly-set-car)))
(define u-call-set-cdr (lambda () (assembly-set-cdr)))

; function application convention
; top of stack is the closure to apply, then the arguments
; this is tricky.  We need to cons the argument list onto 
; the closure's environment,  store the existing
; environment pointer to the stack, set the environment 
; pointer to the new list, invoke the closure's code,
; then restore the environment pointer on return.
;
; (args clos) -> ((clos args)) 
(define assembly-funcall (lambda ()
			   (append-instruction "DUP")      ; (args clos clos)
			    (u-call-car)                   ; (args clos env)
			    (append-instructions 
			     (list "SWAP"                  ; (args env clos)
				   "ROT"                   ; (clos args env)
				   "SWAP"))                ; (clos env  args)
			    (u-call-cons)	           ; (clos (args . env)*)
			    (append-instructions
			     (list "RDRR"                  ; stack is (clos (args . env) renv)
				   "SWAP"                  ; stack is (clos renv (args . env) )
				   "WTRR"                  ; stack is (clos renv) rr = (args . env)
				   "SWAP"))                ; stack is (renv clos) 
			    (u-call-cdr)                   ; stack is (renv clos-code)
			    (append-instructions
			     (list "CALL"                  ; make the call.  we'll have (renv rval)
				   "SWAP"                  ; stack is (rval renv)
				   "WTRR"                  ; stack is (rval) rr = renv
				   ))))

; tail calls are sneakier we avoid saving the current
; env pointer. 
; (args clos) -> ((clos args))
(define assembly-tailcall (lambda ()
			    (append-instruction "DUP")  ; (renv rp args clos clos)
			    (u-call-car)                ; (renv rp args clos env)			    
			    (append-instructions
			     (list "SWAP"               ; (renv rp args env clos)
				   "ROT"                ; (renv rp clos args env)
				   "SWAP"))             ; (renv rp clos env args)
			    (u-call-cons)               ; (renv rp clos (args . env)* )
			    (append-instruction "WTRR") ; (renv rp clos) rr = (args . env)
					                ; note that we didn't store the current env
					                ; this is a tail call so we'll return straight
			                                ; to the current renv/rp!
			    (u-call-cdr)                ; (renv rp code)
			    (append-instruction "JMP")  ; we jump into the call with 
                                                        ;   (renv rp) 
			                                ; on return we'll have pc = rp, and
			                                ;   (renv rval) on the stack
				                   	; just as on return from non-tail call above.
			    ))

; returning is simple since cleanup is handled by the caller
(define assembly-funret (lambda () (append-instruction "RET")))
			   
; assembly for loading a cell from the environment.
(define assembly-env-cell-idx
  (lambda (idx)
    (if (= idx 0)
	#t
	(begin
	  (u-call-cdr)
	  (assembly-env-cell-idx (- idx 1))))))

(define assembly-env-cell-helper
  (lambda (depth idx)
    (if (= depth 0)
	(begin
	  (u-call-car)
	  (assembly-env-cell-idx idx))
	(begin
	  (u-call-cdr)
	  (assembly-env-cell-helper (- depth 1) idx)))))

(define assembly-env-cell
  (lambda (depth idx)
    (append-instruction "RDRR")
    (assembly-env-cell-helper depth idx)))

(define assembly-env-val 
  (lambda (depth idx)
    (assembly-env-cell depth idx)
    (u-call-car)))

(define assembly-nil      
  (lambda ()
    (append-instructions (list "PUSH" "@__nil" "PUSH" (asm-number 0) "LOAD"))))

; Lookup functions,  find a particular atom in the environment
(define lookup-reference-offset 
  (lambda (r e cont)
    (if (null? e) (cont #f)	
	(if (string= r (car e))
	    (cont 0)
	    (lookup-reference-offset r (cdr e)
				     (lambda (z) 
				       (cont (if z (+ z 1) z))))))))

(define lookup-reference-depth
  (lambda (r e cont)
    (if (null? e) (cont #f)
	(lookup-reference-offset r (car e) 
				 (lambda (z) 
				   (cont 
				    (if z 
					(cons 0 z)
					(lookup-reference-depth r (cdr e) 
								(lambda (w) 
								  (if w 
								      (cons (+ (car w) 1) (cdr w))
								      #f))))))))))

(define lookup-reference 
  (lambda (r e)
    (lookup-reference-depth r e (lambda (x) x))))

(define do-compile-task 
  (lambda (t) (if t (do-compile-task (t)) #f)))

; Compilation functions
; These should all be written in explicit continuation passing form
; to avoid excessive stack use when run on the bytecode interpreter
; arguments are always: the form to be compiled, the environment in which
; it would be executed, and the continuation to invoke on completion


(define compile-constant 
  (lambda (c env) (append-instructions (list "PUSH" (asm-number c))) #f))

(define compile-reference 
  (lambda (r env)
    (let ((i (lookup-reference r env)))
      (if i 
	  (assembly-env-val (car i) (cdr i))
	  ; this is an error
	  (begin
	    (display (string-append "Undefined symbol: " r))
	    (exit))
	  )
      #f
      )))

(define compile-atom 
  (lambda (x env) 
    (if (is-number? x)
	(compile-constant x env) 
	(if (string=? "nil" x) 
	    (assembly-nil)
	    (compile-reference x env)))))

; this is right, but breaks the normal continuation passing form 
; of compile-* functions.
;
; Hm, we should probably be flagging code pointers with something
; so that we can avoid gc'ing them. Right now we just assume the 
; code is statically defined below initial heap pointer but in order
; to support eval we'll have to do something more clever.
(define compile-lambda 
  (lambda (l env rest)
    (let ((label (fresh-label)))
      (append-instructions
       (list "PUSH" (string-append "@" label) "RDRR"))
      (u-call-cons)
      (lambda ()	
	(append-instruction (string-append ":" label))
	(let ((r (compile-sequence (cdr (cdr l)) (cons (car (cdr l)) env) #f) ))
	  (assembly-funret) 
	  r)	
	)
      )))

(define compile-begin
  (lambda (l env rest) (compile-sequence (cdr l) env rest)))

(define compile-sequence 
  (lambda (l env rest)
    (if (null? l) #f
	(let ((r1 (compile-sexp (car l) env (if (null? (cdr l)) rest #t) )))
	  (if (not (null? (cdr l)))
	      (append-instruction "POP"))
	  (let ((r2 (compile-sequence (cdr l) env rest)))
	    (lambda ()
	      (do-compile-task r1)
	      (do-compile-task r2)
	      ))))))

; this is right, except that it makes 
; define not work quite the way it is supposed to.
(define compile-define
  (lambda (l env rest)
    (let ((v (lookup-reference (car (cdr l)) env))
	  (r (compile-sexp (car (cdr (cdr l))) env #t)))
      (if v 
	  (begin
	    (assembly-env-cell (car v) (cdr v))
	    (u-call-set-car))
	  (begin
	    (set-car! top-level-env (append (car top-level-env) (list (car (cdr l)))))
	    (assembly-nil)                               ; (v nil)
	    (append-instruction "SWAP")                  ; (nil v)
	    (u-call-cons)                                ; ((v . nil))	    
	    (append-instructions
	     (list "DUP"                                 ; ((v . nil) (v . nil))
		   "PUSH" "@__top_level_env_tail"        ; ((v . nil) (v . nil) &tl)
		   "PUSH" (asm-number 0)                 ; ((v . nil) (v . nil) &tl 0)
		   "LOAD"))                              ; ((v . nil) (v . nil) (? . nil))
	    (u-call-set-cdr)                             ; ((v . nil))  -- list updated to (? . (v . nil))
	    (append-instructions
	     (list "PUSH" "@__top_level_env_tail"        ; ((v . nil) &tl)
		   "PUSH" (asm-number 0)                 ; ((v . nil) &tl 0)
		   "STOR"                                ; () ; tl = v. nil
	      ))))
	  r)))

; when we can detect application of a builtin
; we can avoid function call overhead and just inline the assembly
(define compile-if
  (lambda (l env rest)
    (let ((false-label (fresh-label))
	  (join-label (fresh-label)))
      (let ((r1 (compile-sexp (car (cdr l)) env #t))
	    (x  (append-instructions 
		 (list "PUSH" false-value
		       "PUSH" (string-append "@" false-label)
		       "JEQ")))
	    (r2 (compile-sexp (car (cdr (cdr l))) env rest))
	    (y  (append-instructions (list "PUSH" (string-append "@" join-label) "JMP"
					   (string-append ":" false-label))))
	    (r3 (compile-sexp (car (cdr (cdr (cdr l)))) env rest)))
	(append-instruction (string-append ":" join-label))
	(lambda ()
	  (do-compile-task r1)
	  (do-compile-task r2)
	  (do-compile-task r3)
	  )
	)
      )))

(define compile-arguments
  (lambda (l env)
    (if (null? l) 
	(begin (assembly-nil) #f)
	(let ((r1 (compile-arguments (cdr l) env))
	      (r2 (compile-sexp (car l) env #t)))
	  (u-call-cons)
	  (lambda () 
	    (do-compile-task r1)
	    (do-compile-task r2)
	    )))))

(define compile-list
  (lambda (l env rest)
    (let ((s (find-builtin (car l) (builtin-forms))))
      (if s 
	  (s l env rest)
	  (let ((r1 (compile-arguments (cdr l) env))
		(r2 (compile-sexp (car l) env #t)))
	    (if rest
		(assembly-funcall)
		(assembly-tailcall)
		)
	    (lambda ()
	      (do-compile-task r1)
	      (do-compile-task r2)))))))

(define compile-sexp 
  (lambda (s env rest) 
    (if (list? s) 
	(compile-list s env rest) 
	(compile-atom s env))))


; The builtin functions are a little peculiar.
; The convention is 
;     :foo is the closure cell for the foo function,
;     :__foo is the entry point when called as a closure
;            (i.e., arguments are retrieved from the env pointer)
;     :__u_foo is the entry point for internal invocations
;            (e.g., during closure invocation). arguments are read
;            from below the rp on the stack
;     :__foo_body is the actual implementation of foo,  arguments
;            are read from the top of stack
;
(define define-builtin-functions
  (lambda ()
    (append-instructions     
     (list ":cons" "@__nil" "@__cons"   ; this is the closure cell
	   ":__u_cons"                  ; this is the internal entry point
	                                ; stack is (cdr car rp)
	   "ROT"))                      ; stack is (rp  cdr car)
    (assembly-cons)                     ; this is the internal cons used when building arg lists
    (assembly-funret)                   
    (append-instruction ":__cons")      ; this is the exposed cons, it plays a little trick
					; with the environment list by loading the second arg,
					; grabbing the cons box containing the first arg,
    (assembly-env-val 0 1)              ; then overwriting the cdr pointer and returning.
					; this is safe since the cons boxes surrounding the 
					; arguments are allocated in assembly-funcall
    (assembly-env-cell 0 0)             ; so it is guaranteed to not be shared.
    (append-instructions                ; stack is (cdr &car)
     (list "DUP"                        ; (cdr &car &car)                       
	   "ROT"                        ; (&car cdr &car)
	   "PUSH" (asm-number 1)        ; (&car cdr &car 1)
	   "STOR"))                     ; (&car)
    (assembly-funret)					

    (append-instructions
     (list ":car" "@__nil" "@__car"     ; closure cell	   
	   ":__u_car"                   ; internal entry point
	                                ; (arg rp)
	   "SWAP"                       ; (rp arg)
	   "PUSH" "@__car_body"         ; (rp arg __car_body)
	   "JMP"                        ; jump to the body
	   ":__car"))                   ; closure entry point (arg is in env)
    (assembly-env-val 0 0)              ; stack is (renv rp arg)
    (append-instruction ":__car_body")  ; now we're at the body
    (assembly-car)                      ; dump the assembly for car
    (assembly-funret)                   ; and a return statement

    (append-instructions                ; this is completely analogous to above
     (list ":cdr" "@__nil" "@__cdr" 
	   ":__u_cdr"
	   
	   "SWAP"
	   "PUSH" "@__cdr_body"
	   "JMP"
	   ":__cdr"))
    (assembly-env-val 0 0)
    (append-instruction ":__cdr_body")
    (assembly-cdr)
    (assembly-funret)

    ; arithmetic ops
    ; these aren't used internally so we just define them.
    (append-instructions
     (list ":add" "@__nil" "@__add :__add"))
    (assembly-env-val 0 0)
    (assembly-env-val 0 1)
    (append-instruction "ADD")
    (assembly-funret)

    ; the vm doesn't actually define subtraction, 
    ; we multiply by -1 and add.
    (append-instructions
     (list ":subtract" "@__nil" "@__subtract :__subtract"))
    (assembly-env-val 0 0)
    (assembly-env-val 0 1)    
    (append-instructions (list "PUSH" (asm-number -1) "MUL" "ADD"))
    (assembly-funret)

    (append-instructions
     (list ":multiply" "@__nil" "@__multiply" ":__multiply"))
    (assembly-env-val 0 0)
    (assembly-env-val 0 1)
    (append-instruction "MUL")
    (assembly-funret)

    (append-instructions
     (list ":equal" "@__initial_env" "@__equal" ":__equal"))
    (assembly-env-val 0 0)
    (assembly-env-val 0 1)
    (append-instructions
     (list "PUSH" "@__equal_true" "JEQ" 
    ; they weren't equal! push false and exit
	   "PUSH" false-value)) 
    (assembly-funret)
    ; they were equal! push true and exit
    (append-instructions
     (list ":__equal_true" "PUSH" true-value))
    (assembly-funret)
    )
)

(define assembly-preamble
  (lambda ()
    (append-instructions 
     (list 
      ; initial trampoline past the definition of nil
      "PUSH" "@__main" "JMP"
      ; here's the definition of nil (we're at address
      ; 3 at the moment so 0x10000003 is @__nil & ptr-flag).
      ; note that these will all break if the object representation
      ; changes.
      ":__nil,2"          "@__nil"       "@__nil"
      ":__multiply_box,2" "@multiply"    "@__nil"
      ":__subtract_box,2" "@subtract"    "@__multiply_box"
      ":__add_box,2"      "@add"         "@__subtract_box"
      ":__cdr_box,2"      "@cdr"         "@__add_box"
      ":__car_box,2"      "@car"         "@__cdr_box"
      ":__cons_box,2"     "@cons"        "@__car_box"
      ":__equal_box,2"    "@equal"       "@__cons_box"
      ":__initial_env,2"  "@__equal_box" "@__nil"

      ":__top_level_env_tail,1" "@__multiply_box"
      ))
     (define-builtin-functions)
     (append-instructions 
      (list 
       ":__main" ; now initialize the heap pointer to point somewhere
       "PUSH" "@__initial_env"
       "WTRR")) ; set the initial env pointer
     ))


(define compiler-run 
  (lambda (ch)
    (let ((sp (read-sexp ch)))
      (if (car sp)
	  (let ((r (compile-sexp (car sp) top-level-env #t)))
	    (do-compile-task 
	     (lambda () 
	       (compiler-run (cdr sp)) r)))
	  (append-instructions (list "PINT" "END"))))))

(define read-atom-helper (lambda (ch)
  (if (or (eof-object? ch) (or (isspace ch) (char=? ch #\) )))
      (cons #f ch)
      (let ((x (read-atom-helper (read-char))))
	(cons (if (car x)
		  (cons ch (car x))
		  (cons ch '())) (cdr x))))))

(define read-atom (lambda (ch) 
		    (let ((x (read-atom-helper ch)))
		      (if (car x) 
			  (cons (list->string (car x)) (cdr x))
			  x))))

(define read-list 
  (lambda (atc)
    (if (char=? (cdr atc) #\) )
	(cons (if (car atc) (cons (car atc) '()) '()) (next-non-ws) )
	(let ((x (read-list (read-sexp (cdr atc)))))
	  (cons 
	   (if (car atc)
	       (cons (car atc) (car x))
	       (car x)) (cdr x))))))

(define read-sexp (lambda (ch)
		    (if (char? ch)
			(if (isspace ch)
			    (read-sexp (next-non-ws))
			    (if (char=? ch #\( )
				(read-list (read-sexp (next-non-ws)))
				(read-atom ch))
			    )
			(cons #f ch)
		    ))
  )
  
(assembly-preamble)
(compiler-run (next-non-ws))